# P1.4 State Tracking

**Status**: 🧪 **NEEDS TESTING**  
**Priority**: 1 (Core Session Tracking)  
**Current Implementation**: Pattern matching foundation built, Claude-specific patterns needed

## Overview

State Tracking monitors Claude CLI output to detect when sessions transition between 3 simplified states: WORKING → PENDING → IDLE. Uses a minimal, silent background approach that doesn't interfere with Claude's display.

## How It Works

### Current Implementation

**Silent Background Monitoring** (`tools/tl-wrap.js`):
```javascript
let outputBuffer = '';

// Clean passthrough - no interference with Claude display
ptyProcess.on('data', (data) => {
  process.stdout.write(data);  // User sees output normally
  outputBuffer += data;        // Silently collect for state detection
});

// Process state changes silently every 0.5 seconds
setInterval(() => {
  if (outputBuffer.length > 1000) {
    const recentOutput = outputBuffer.slice(-1000);
    
    // Simple pattern matching without console output
    if (recentOutput.includes('esc to interrupt') && recentOutput.includes('tokens')) {
      stateTracker.changeState('WORKING', 'Claude is processing', 'high').catch(() => {});
    } else if (recentOutput.includes('❯ 1. Yes')) {
      stateTracker.changeState('PENDING', 'Claude needs approval', 'high').catch(() => {});
    } else if (recentOutput.includes('> ') || recentOutput.includes('? for shortcuts')) {
      stateTracker.changeState('IDLE', 'Claude ready for input', 'high').catch(() => {});
    }
  }
}, 500);
```

**State Update System**:
```javascript
async function updateTaskState(newState, details = '') {
  try {
    await makeRequest('POST', '/v1/tasks/state', {
      taskId: taskId,
      state: newState,
      details: details.trim()
    });
    console.log(`[Tally] Task ${taskId} → ${newState}`);
  } catch (error) {
    console.error(`[Tally] Failed to update state:`, error.message);
  }
}
```

### Backend State Management

**Rust Handler** (`src-tauri/src/lib.rs`):
```rust
#[tauri::command]
async fn update_task_state(req: UpdateTaskStateRequest) -> Result<(), String> {
    let mut store = STORE.lock();
    
    if let Some(task) = store.tasks.get_mut(&req.task_id) {
        task.state = req.state; // Now accepts Claude states directly
        task.details = req.details.unwrap_or_default();
        task.last_event_at = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs();
        
        // Emit real-time update
        if let Some(app_handle) = &*APP_HANDLE.lock() {
            app_handle.emit("tasks-updated", &*store).ok();
        }
    }
    
    Ok(())
}
```

### Current State Model

**Simplified 3-State System:**
- `WORKING`: Claude is actively processing (pattern: "esc to interrupt")
- `PENDING`: Claude is waiting for user input (pattern: "❯ 1. Yes")  
- `IDLE`: Everything else (default state, no error detection)

## Issues with Current Implementation

### 1. State Model Mismatch

Claude CLI doesn't follow our 6-state model. **Real Claude behavior**:

```bash
# Claude session starts
> help me debug this code
⏺ Thinking...                    # Should be: THINKING
⏸ Here's what I found...         # Should be: RESPONDING
> Apply these changes? [y/N]     # Should be: WAITING_FOR_APPROVAL
✓ Changes applied                 # Should be: RUNNING
> /exit                          # Should be: IDLE (session continues)
```

**Current Claude State Model** (Simplified):
- `IDLE`: Waiting for user question (default state)
- `WORKING`: Claude is actively processing ("esc to interrupt" pattern)
- `PENDING`: Claude is asking for permission ("❯ 1. Yes" pattern)

### 2. Missing Pattern Detection

**What we need to detect**:
```javascript
// Claude-specific patterns needed
const claudePatterns = {
  thinking: /⏺.*[Tt]hinking/,
  responding: /⏸.*/, 
  approval: /Approve\?\s*\[y\/N\]/,
  error: /(Error:|Failed to|Cannot|Unable to)/,
  welcome: /Welcome to Claude/,
  session_end: /Goodbye!/,
  model_switch: /Switched to (claude-3|sonnet|haiku)/
};
```

**Current missing detections**:
- ⏺ Thinking indicators
- ⏸ Response completion
- Model switching alerts  
- Session start/end events
- Tool execution states

### 3. ANSI Code Interference

Claude uses complex ANSI formatting that interferes with pattern matching:
```javascript
// Raw output includes:
"\x1b[2K\r⏺ \x1b[36mThinking...\x1b[0m"

// Current cleaning too basic:
const cleanLine = line.replace(/\x1b\[[0-9;]*m/g, '');
// Misses cursor movements, complex sequences
```

## Testing Requirements

### 1. Pattern Matching Validation

**Test each Claude state transition**:
```bash
# Test script needed
tally claude
> help me with this code    # Should detect: IDLE → THINKING
# Wait for response         # Should detect: THINKING → RESPONDING  
> Apply the fix? [y/N]      # Should detect: WAITING_FOR_APPROVAL
y                           # Should detect: RUNNING
> /exit                     # Should detect: IDLE
```

**Verification**:
- Dashboard shows correct state changes in real-time
- State transitions logged correctly
- No false positives from similar text

### 2. Real-world Scenario Testing

**Complex interactions**:
```bash
tally claude
> debug this authentication bug
# Claude asks clarifying questions
> the login form validation
# Claude provides solution
> Approve? [y/N]
n
> modify the approach slightly  
# Claude provides alternative
> Approve? [y/N]
y
# Success case
```

**Edge cases**:
- Network interruptions
- Claude CLI crashes
- Mixed terminal input/output
- Multiple approval prompts
- Long-running operations

### 3. Performance Testing

**Output volume handling**:
- Large file displays
- Rapid state changes
- Buffer overflow scenarios
- Memory usage patterns

## Dependencies

### Pattern Matching
- **ANSI parsing**: Need robust ANSI code removal
- **Unicode handling**: Claude uses various Unicode symbols
- **Line buffering**: Complete line processing only

### State Persistence
- **Real-time updates**: Tauri event system
- **Storage**: JSON persistence (pending implementation)
- **Recovery**: Handle missed state transitions

## Known Limitations

### 1. Pattern Fragility
- Hardcoded text patterns can break with Claude updates
- Language-specific prompts (non-English Claude)
- Custom Claude configurations

### 2. Terminal Complexity
- Mixed stdout/stderr streams
- Cursor positioning effects
- Terminal size dependencies

### 3. Timing Issues
- Race conditions between output and state updates
- Network latency to Tally backend
- Buffer flushing delays

## Future Improvements

### 1. Claude-Specific Integration
- Research Claude CLI's internal state API (if available)
- Monitor Claude's log files or temp directories
- Hook into Claude's internal event system

### 2. Robust Pattern Engine
```javascript
// More sophisticated pattern matching
class ClaudeStateDetector {
  detect(rawOutput) {
    const cleaned = this.cleanANSI(rawOutput);
    const context = this.getContext();
    return this.matchPatterns(cleaned, context);
  }
  
  private matchPatterns(text, context) {
    // Context-aware pattern matching
    // State machine approach
    // Confidence scoring
  }
}
```

### 3. Machine Learning Approach
- Train on Claude session logs
- Fuzzy pattern matching
- Adaptive pattern updates

## Testing Plan

### Phase 1: Basic Pattern Testing
1. **Manual verification**: Run `tally claude` and verify each state change
2. **Log analysis**: Compare detected states vs actual Claude behavior
3. **False positive detection**: Test with non-Claude terminal output

### Phase 2: Integration Testing  
1. **Dashboard updates**: Verify real-time UI changes
2. **Notification triggers**: Test WAITING_USER detection
3. **Session lifecycle**: Full session start-to-end tracking

### Phase 3: Stress Testing
1. **Multiple sessions**: Concurrent Claude sessions
2. **Long sessions**: Extended interactive sessions  
3. **Error scenarios**: Network issues, Claude crashes

## Success Criteria

**✅ Ready when**:
- Detects all 3 Claude states correctly (IDLE, WORKING, PENDING)
- 95%+ accuracy on state transitions in testing
- No false positives from normal terminal usage
- Real-time dashboard updates work consistently
- Simple pattern matching is reliable and fast

## Current Status

**✅ COMPLETED**: Minimal silent state tracking system
- ✅ Clean PTY passthrough with zero display interference
- ✅ Silent background state detection every 0.5 seconds
- ✅ WORKING: "esc to interrupt" + "tokens" pattern
- ✅ PENDING: "❯ 1. Yes" pattern  
- ✅ IDLE: "> " or "? for shortcuts" pattern
- ✅ No console output from tracking system
- ✅ Error handling prevents crashes
- ✅ Memory management with 1000-character rolling buffer